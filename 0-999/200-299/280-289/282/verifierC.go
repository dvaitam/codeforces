package main

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"strings"
)

// Embedded testcases from testcasesC.txt.
const embeddedTestcasesC = `1011111100100 1010011011101
100010110100000 100110110101101
01000011000 00011001111
010110001001 011000000000
01010000001000101000 11100100101110000011
1111011000 0101101100
110111 110001
11011100100 11100000111
00010100 10001110
11000101110001 00100101110011
111100111100110 101100101010010
011000101001 111110010000
110100110001111 010001010000000
111101000101010 001001110100010
111111010010111111111111 011100101111111010010101
0100101100101 1100101011111
01101010111101001 10110101000111110
1100011100001 0001011111000
10101011000100 00101110010100
011001100010110000100 101011111100001110110
000100100010000111 110111000101000101
111010011101110 111000010100011
011101111011 011011101100
110000011000 110010001111
10000100 10011000
1111100101001 1001010000001
000110 000010
111001101001001110110 010011100011101000010
1010110 0101000
1110011001 1001100011
0101101000000 1001100010101
011101100011010100000 100011111011111011100
000100111 110011101
1100001011001000 1001011101000011
111010100100101 101100000100111
111000000001 001000110010
110000101100 111010010100
01010100111001 01000110011111
011011111111001 000011101100101
00001100 01000011
01011011011111010 00001010101011011
11011100101 00110100001
100100111000 001000111100
1111001010 1010001111
10000001000101 10000011101011
101110110001100 110111100000011
010011101 100010111
00011010111100111100110 11110111000001010011101
0111101001110 0101110101001
101011010100 010100000000
011011001111 111001000100
000001100111101 000110000011010
1010010111101 0110010010100
0101111010111011 0111010100011001
0110111100000100000101 1111111011001100101001
010010010001 100110101100
001111000 111111001
110000100 111001111
010001001 100010001
00000101000101001 01101011111101100
111111000 101110000
110110010010100 111001010110101
1111001000000001 1001001010000011
010110110001100010 100100101010001110
0100111111010 1100011000011
110100001110011110101 010111000101101110100
100011 110101
001110100111110 001011011100001
011100000010 111010110101
000011000010 110011111001
10010000100010111000 01111010110010001010
1101111000001010 0100100000110111
101101011000010 010111101100001
11111010 11101000
1101110111001010011 1001010011001011010
010010111001101 011010011010110
100101011001111100 110001010111100110
1110010110000011011 0000011111111101010
110001110111 000000110000
0001010110000001000 1101010011111010101
000010101010 011100001110
000010 010110
10111110110101 00100011100111
110001111101101100000001100 001001101011111101111110011
010000110000 101001011001
110110110100 101010111100
0010001101111 0000100110110
010111011 010100110
1011011101 0010010000
111110100101 101011001111
001100000000010101111 010111001001000000100
00100101011101010111000 01111010101001010111100
11110101100010000 10101101001111101
001011001111100110 011100100000000110
01010011101101 01010001101011
01111000001110111 10101011010000110
000010010011000 101101111000011
111000001 001010011
1100110111 0001001111
0111001001 1110010101
000001 001010
100001000000010 011010001100100
01010100010 00001101110
11011100110 10011011010
01101001001110100100 00101010111011010111`

func solve(a, b string) string {
	if len(a) != len(b) {
		return "NO"
	}
	hasA1 := strings.Contains(a, "1")
	hasB1 := strings.Contains(b, "1")
	if hasA1 == hasB1 {
		return "YES"
	}
	return "NO"
}

func runCandidate(bin, input string) (string, error) {
	cmd := exec.Command(bin)
	cmd.Stdin = strings.NewReader(input)
	var out bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return "", err
	}
	return strings.TrimSpace(out.String()), nil
}

func main() {
	if len(os.Args) != 2 {
		fmt.Println("usage: go run verifierC.go /path/to/binary")
		os.Exit(1)
	}
	bin := os.Args[1]
	lines := strings.Split(strings.TrimSpace(embeddedTestcasesC), "\n")
	for idx, line := range lines {
		parts := strings.Fields(line)
		if len(parts) != 2 {
			fmt.Fprintf(os.Stderr, "test %d: invalid line\n", idx+1)
			os.Exit(1)
		}
		a, b := parts[0], parts[1]
		input := a + "\n" + b + "\n"
		want := solve(a, b)
		got, err := runCandidate(bin, input)
		if err != nil {
			fmt.Fprintf(os.Stderr, "case %d failed: %v\n", idx+1, err)
			os.Exit(1)
		}
		if strings.ToUpper(strings.TrimSpace(got)) != want {
			fmt.Fprintf(os.Stderr, "case %d failed: expected %s got %s\n", idx+1, want, got)
			os.Exit(1)
		}
	}
	fmt.Printf("All %d tests passed\n", len(lines))
}
