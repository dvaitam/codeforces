package main

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"strings"
)

// Embedded copy of testcasesA.txt so the verifier is self-contained.
const testcasesA = `100
52 1111111111111111111111111111101111111111111111111111
96 001011001011010110100001101010100000111110110000110010001100001001100110101110110000101010100101
19 0111000010001001100
30 111111101011111101101101101111
24 111110010110010001100110
76 0010101100010011000000011011000000100001000000010010010000000100000000100000
36 010011000000001000010010000100000000
67 1111111111111111110101111110111011111111101111111111111111111111111
86 10001000000000000000100010001010000000000010000010000100010000000000000010001000010000
54 111110101011111011011001111111111111111111111111111111
18 110001111110001000
38 11111111111101111110011101111110011101
20 00100100101110000010
82 0000010000000000000110000000000000100100000000100000000000000000000000000010000000
53 01111111111111011011011001100111111010010111011111010
13 1101001000110
53 01011111101011111011111110011001110111010111110011101
51 100000100110101000001111011110010110111111000010011
7 1111111
11 11010000100
19 1000000001100010000
23 00000000000110101101100
7 1111111
40 1111111111111111111101111011111111110111
48 011100101110101100011010110011110101001101111101
86 00001100010000011000000010000000100001000000010101100000101000100010000000000001100000
6 111100
42 000011100100000000000000001100000001100110
22 0000000000000110000001
56 00000000000000000000100000000001000000000000001000000001
35 10001001000100000000001000001001001
25 0010000100010000000000000
79 1101000010000111001001010010010001000100000010010000000000100100000010000000011
63 000001101111001100111000100000001011010010000000000000011101000
33 111111110111110101111110011101111
50 10111111011111111111111110101111110011111110111111
30 001110010100010101011100100000
72 101011111111111111111111101010101111111110010001111111110101010010011111
18 001000001010101001
41 11111010010111111001101100100011100100111
90 100001000000001000000000000001000010010000000010001000000000000000000000000000010100010101
21 111111111111111111111
59 00110100000111100000000110011001000001101100111000110101011
81 101110101011101000100110010101001011101001010101101010010110101011101010001000101
16 1110110110111110
50 00000000000011001001001000000000010000000001001000
42 111110111101111110011111111111111111111001
65 00000010000010001010101000011000001100010000010001100000100100010
68 11111111111111111111111110110101111111011110111111111111111101111111
29 11111111110111111111111111111
97 1011100111110111110111101011110101110101111111000101110010101011001011111010010001111001111010111
100 1000000000000001010001000000000000000000000000000100100000000000100000001000000000000000000000000000
82 1111011011111101111101111100011111111111111110111011101111110011011110111111111111
35 11001101001100010010011101011100000
49 1010001011100000101111010101101100001010100000001
11 11111111111
37 1100101000111110111010101111000010111
84 111111111111111111111111111111111111111111111111111111111111101111010111111111111111
54 001101001011100010000010100000101101101011001101001000
36 011111100110001011101000110011111111
61 1101111110110000000111111001101011111010010001011110000011111
8 10110111
94 0001001011001001000000011000000011000001000001000100100010100000000000001000010100100010100101
47 00000000000100000000000001000000000000010000100
86 00000000000000000000000000000000000000000100000000000000001000010000001000000000000000
63 000100000000000000000000010000000010000000000000001000110100001
36 000001100000000000000100000000000100
48 101000000100000000100000100000100100000010000010
46 0110000001110011000001000100001000010000001010
33 101011010001111110111111011011101
6 101111
76 0001001011000000010100100011000100001000001000101001010110000000011000100000
34 1111011111111111111111111111111111
58 0000000000100000000001000010011000000010000001000000010010
23 10111111111111111111110
58 0000000000000000010000001010000000000000000100100000000000
29 10111100000111100111010000001
72 000100010000000001110100001001000000000100010101001100001100000110001001
55 1111011111111111111111111111101011111111111111111111111
77 01010100111000101000110011101100100011000101010000001001110010100111111100010
8 01111101
36 001010000010101100010001011100010011
75 101000111111111111110110010101110101011010111110111111011111011111111101010
100 0000000000000001100000000100010000011000000001010101000100001100100000000000001010011000001000010001
48 000000110101101110110110101011111110100010111110
65 10110100000000101000100001110010000010001000000001001000010000100
28 1101111111111111111111101111
71 11100000100000000100011110100100000001110101010010001101000010000001011
69 000100001000010000100000100000001010100100100000010000000000100000110
43 0000001100110010010000000010101010011001110
19 1011011111111111011
100 0000101101011101001111001001111111101111101111101110111010111111001010100110100001111110111100000000
79 1110111101101110011011110101110110111111101101101111011110110111011111111100011
88 0111000010100000000000000010001000000001000000101000010000000011000111000001011000100000
68 11111101110111101101111010011011111111111000111100011101111101011110
40 1011100010111101110111000110010111111101
12 111111111111
28 1100111011110011110111111111
13 1111101111111
67 1111110110111111111110101111010011111110111110111111110110111111101`

// Embedded solution logic from 36A.go.
func solveCase(n int, s string) string {
	pos := make([]int, 0, len(s))
	for i, ch := range s {
		if ch == '1' {
			pos = append(pos, i)
		}
	}
	if len(pos) < 3 {
		return "NO"
	}
	d := pos[1] - pos[0]
	for i := 2; i < len(pos); i++ {
		if pos[i]-pos[i-1] != d {
			return "NO"
		}
	}
	return "YES"
}

type testCase struct {
	n int
	s string
}

func parseCases() ([]testCase, error) {
	lines := strings.Split(strings.TrimSpace(testcasesA), "\n")
	if len(lines) == 0 {
		return nil, fmt.Errorf("no testcases found")
	}
	// first line is t
	tLine := strings.TrimSpace(lines[0])
	if tLine == "" {
		return nil, fmt.Errorf("missing test count")
	}
	var t int
	if _, err := fmt.Sscan(tLine, &t); err != nil {
		return nil, fmt.Errorf("bad test count: %v", err)
	}
	if len(lines)-1 < t {
		return nil, fmt.Errorf("expected %d cases, got %d", t, len(lines)-1)
	}
	cases := make([]testCase, 0, t)
	for i := 0; i < t; i++ {
		line := strings.TrimSpace(lines[i+1])
		if line == "" {
			return nil, fmt.Errorf("line %d empty", i+2)
		}
		var n int
		var s string
		if _, err := fmt.Sscan(line, &n, &s); err != nil {
			return nil, fmt.Errorf("line %d parse error: %v", i+2, err)
		}
		cases = append(cases, testCase{n: n, s: s})
	}
	return cases, nil
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("usage: verifierA /path/to/binary")
		os.Exit(1)
	}

	cases, err := parseCases()
	if err != nil {
		fmt.Println("could not load testcases:", err)
		os.Exit(1)
	}
	for i, tc := range cases {
		expected := solveCase(tc.n, tc.s)

		var input bytes.Buffer
		fmt.Fprintf(&input, "%d\n%s\n", tc.n, tc.s)
		cmd := exec.Command(os.Args[1])
		cmd.Stdin = bytes.NewReader(input.Bytes())
		out, err := cmd.CombinedOutput()
		if err != nil {
			fmt.Printf("case %d: runtime error: %v\n", i+1, err)
			os.Exit(1)
		}
		got := strings.TrimSpace(string(out))
		if got != expected {
			fmt.Printf("case %d failed: expected %s got %s\n", i+1, expected, got)
			os.Exit(1)
		}
	}
	fmt.Println("All tests passed!")
}
