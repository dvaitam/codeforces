package main

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"strconv"
	"strings"
)

const testcases = `
100
KVKKKKKKVVKVVKVKVVKKVKKKVKKKVVVKVKKVKVVVVVKVVKKVKK
VKVKKVKKVKVVVVKKVVVVVVKKVVKKKKKVKVKKVVVKVVKVKKVVVVVVVVVVKVKVVVVVVKVVVKVKVVVKKKVVKVVKVKKKVVV
VVKKVKVVKKKKKKVVKVKVKVVKKKKVKKKVVVKVVVKKKVKKVVKVKVKKVVKKKKVKVVVVKKKVVVVVVVVKKVVKKVVKKVK
KVVKVVVVKKKVKKKKVV
KVVVKKKKVKVVKVVKKKVKVKVVKVVKKKKKVVKKKKVKVKKVKKVVK
VVVVVVKVVKKKKVKVKVKVKVKVVVKVVKKKVVVVVVKKKVVKVKKKKKKVVVKKKVVKVKKKVVVVVVVKVKKVVKKKVV
VKVKKKKVVVVKKKVKKKKKKVVVVKKVVKKVKVVKKVKKKVVKVVVVKVKVKKVVKKVKVKKVVVKKKVKKVVVKKVVVVKKVVKK
VKVVKVVKKKV
KKVKVVKVKKVVVKVVVVVVVKKVVVVKVKKKVVVKKKKKKVVVKVKVVVKVVVKKKVVVKVVV
KKVKKKVVKKVKKVKKKVKKKVVVKVVKKVKKVVKKVKKVKVKVKKVVKVKVKK
KVKKVVKVVKKK
VKKKVVVVKKKVVVVKKKVVVKKKKKKVVVVKKKVKKKKVKKKKVKKVKVVVKKKVV
VKVKVVVKKVVKVVKKKKVKKKVKVKVVVKKKKKKVVKVVKVVVVKVVVKVKKKKVKKKKKVKKVVVVKVKVVVKVKVKVKVVKKKKK
VVKV
KVVKKKKKKKVVKVVKKKVKKKKVVVV
VKVKVKKVVVKVV
KKKVKVKKKKKVVVVVKVVKVKVVKKVKVKVVVKKV
KKVVVKKVVKVVVVVKVVVVKKVKVVKKKKVVVKKKVKVKVKKKVVVK
VKKVKKVKVKVVKVKVVVVVVKVVKKVVKKVKKVKKKVKKKVVKKVVVVVKVVVVVVVKVKVVKKKVVKVKKVKVKVKKKKKVKKKVKVKKVK
KVVKVKKVKKKVVKVKVVKVVVKKKKKKKKVVVVKVKVKKVVKKV
VVVVKKKKKVKKKKKVKVVVKKKVKVVKVVKKVVVKVKVKVKVVVKVKKKKKKKVKVKVKVKKKKVKK
VKKVKKVVVKKVVVVKVKVKKVKKVVKKVVVVKVVKVKVVVKVKKKKKVKVVVVKVVKVKVKVKVVKVVVKKK
KKVVKVVVVKVVKVKKVVKVKVKKKKKKVVKKVKVKVVVKVVK
VKKKKVVKKVVVKKVKVVKVVKKVVVVVVKVKKVVVKKVVKVVKKKVKVVVKVVVVKVVVVVVKVKKKVVKVKVVKKVK
VKKVKVKKVKKKVKVKVKKVVVKVKKKVKKVVKKKVKVKKVKKVVKVKKKVKKVKK
VKVVVKVVKKKVVKVVVVVVVVKKKKVKKVKKVKKVKKKKKKKVVVVVV
VKVKVVVVKKKVKKKKVVVVVVKVKKKVVKVKVKVKKVKVKVKKKKKVVKVKVKVVKKKVKKVVKVKVVVVVVVKKV
KKVVVVKKKVVKKKVVKKVKKVVKVKKKKVVKKKVKKKKKKKVKKVKVKVVKKVVKKKKVK
KKVKVVKKKVKVVKVKVKVVVKVVVVKVVVVVKVVKVVVVKKKVKVKVKVKKKKVVKVVKVVVKV
KVKVVKVKKVKKVKKKVKVKVKKKVKVKKVKVKKKVVKKKKVVVKVVVKVKVKKVKKVVKVKVKVKVKVKVVKK
VVVVVVKVVKKKKVVKKKKKKKVVVVVKKVKVVKVVKKVVVKKKVVKVVKKKVVVVKVKKVKKVKKKVKVVV
KVKKKKVVKVVVVKVVKKKVKKKVVKVVKVKKVKVKVKVVV
VVKVVVVKVKKVKKVVKKVKVVKKKVVVKVVKVKKVKKVVKKVKVKKVVVKVKKKVVVKVKKK
VKKKKVKKVVVKKVVVKVVVKVKKVVKKKKKKVVKVVVVKVVKVVVKVVVVVKVKVVKVKKVKKVVVVVVVKKKK
KKVVVVVVVKVKVKVVKKKKKVVKVKKKKKVKKKKKKKKVVKVKV
VKKKKKKVVKKVVVVKVVVVKKVVVVKVKKKKVKVVVVKKVKVKVVKVKVVVKVVVKKKVVKVKKK
KKVKVVKKKKVKVVVVKKVKKKVKVVVVVVKKKVKVVKVVVKVVKVKKKVKVVVVVKKKKVK
VVVVKVVVVKVKVKVVKVKKKKKVVKKKKKKVVVKKVVVVVKVVKKKKKKKKVVKKKVVVKVKKVVVVKVKVKKKKKVVKKVVKVKKK
VKVKKKKVKKVKKKVVKVKKVKVKVVKV
VKKVVKVVKVKKKVKKKVVVVVKVKKKKKKVVVKVKKKKKKVVVVVKVVVVVKVKVVKKVVVVVVKKKV
KVVVKVVVKKVKVKVVVVVKVVKVKVVKKKVKVVKKKKKVKKVVKVVVKVKKVVVKKKKVKKKVVVKKKVKVKVVKVKVVVVVVKKVVVVKVVVV
VKKKKVKKVVVKVVVVVKKVKKKKKVVKKVVVKVVKKVKVVKKVKVVKKKKVVKVKVVKKVVKKVVVVKKVVKKVKVV
VVVVKKKKVVVVKVVVVVVVVVKVKKKKVVVKVKKKKKVKVVVVVVKKVKKVKKVKVKKVKKVK
KVKKVKKKVVVKVKKVKKK
KVKKVVVKKVVKKKVKKVVVKKKVKKKKKVVKVVVKKVKVKVKVKKVKVVVVKKKVVKKKVKKVVV
KVKVKVVKVVVVKV
KKVKVKVVVKVKVKKVKKVKVK
VKKKKKKKKVVVKKVKKKVVVKVVKKVVKKKKKVVVVKVVKKVVKVKKVVKKKKVVVKKKKVKKKVKKKVKKKKKKKK
VKVKKKKVVKVKVKVVKVVVVVVVKKVKKKKVVKVVVKKKKKVKKKVVKVKKVKVKVVVKVKKVVVVVVKVVVVV
VVVVKKVVKK
VVVKKVVVVVKKKKKVVVKKKKKVVVVKVVVVKKVKKVVVKKVVKVKKVVVKKVKKKVKVKVKKV
VKVKKVKVVKKVVKVVKKVKVVVKVKVVVVKKKK
VVKKVKVKVVKKKVVKKKVKVVVKVVVKVKKKKKKKVKKKKKKVKVK
KVVKVKVVKKKKKKVVKVKKVVVVKVKKKVKKKKV
VKKKVKVVVVKVVVKKVVVKVKVKKVKKVKVVVKKKVVKKKVVKKKKKKVKVKVKVVKKKKKKVVKVKVKVVKKVVKVKKVVKKKKKVVKVVVKVVKVVK
VKKKVVVVVVKVKVVVKKVKKKVKKVVVVKKVKKKKVVKVKVVVVKKVKVVKVVVKKKKKKVVKVVKKVVVKKKKKVKKVVKVVVVVVVKKVVVVV
KKKVKVVVKVKVVVVKKKKKKKKKKKKKKKKVVKKKKVVKVVVVKVV
KVKVKVVVVVVVVVKKVVKKVKVVKKVVKVVVVKKKVKKVVKVVVKKVKKVKVKKKVKVKKVVKKVVVKKVKKKKVKVKVVKKKV
KVKVKVKVVVKKVKKVKVVVVVVKVVKKKKKKVKKKVKVKKVKKVVKVVKKVKKVKVVVKKVV
VVVKKVVVVKKVVKVVVVVKVKVVKVKKVKVKKVKKKVKVKVVKVKVKKKVVKVVVVVKKVVVVVKKKVKVKKVKVVKKVVKKVVVV
VKKKKVVKKVKVKVKVKKVKKVVVKK
VVVVKVKVVVKKVKVVVKKKVVKVKVKKK
VKVKKVKVVVVKVKVKKVVKVKVKVVKKVVVKKVKKVV
KVKKKKVVKK
VVKKKKKKVKVKVKVVVKVKVKKVVKKKVVVVVVKKKVKVVKVVKVVKVVVKKKKVVVKKKVKKV
VVVKKKKKVKKVKKKKVVKKKVVKVKVVVVKVKVVVKKKVVKKKVVKVVVVVVKVVVK
KKKKVVVVVVVVVVKKKKVKVVKKKVKVKKKVK
KKKKVKKVKKVVKVVVVVKKVVKVKKKVKKKKKVKVKVVKKKKKVVKKKKVVVVKKKKVKKVKKVKKKKVKVKV
KKKVKVVKVVVKKKVKVVKKVVKVKVKVVVVKKKVKKKKKVVVKVK
VVVVVKVVKKKVKKVVKKKKVKVVVVKVVVVVVVVVKKVKK
VVVKKKVKKVKVKKVVVVVKVVKKKKKVKKKVKVKVKKVKKKKVK
VVKKVVKVVKKVVKKVKVVKKKKKKVK
VKVKVKVVKVKKKKVKVKVKVKV
KVVVKVKVVKKKKVVKKKKVKKKKVKVVKKVKVKKVK
VVVKVVKVVVVVKKKVVKKVKKKKVVVKKKKVVKK
VKKVVVVKKVKKKVVVVKKVVVVKVKVKVKVVVKVVVKKVVVKKVVKKKVKVVVKKVVVKKVKVVKVVKKVKVVVVVVKKVKVVVK
KVKKVKKKVKVVKKKKKVVKVVK
KVKKVKVKKVKVKVVVVKKKKVKVKKVKVVKVVVVVKKVVVVVVVKKKVVKVVVKKVVVVVKKKKVVKVKVVKKKKKKVVKVKKVKKK
KKVVKKVVVKVKVKKVKKKVKKVVVKKVKKVVVVKKKKKVKKVVVVVVK
VKKVVKVVVVVVKKKVKKVVVVKKVKVKVKKVKKKVVVVVKKKVVKKVVVKVKKK
VVVVKVKVVVVKKKKKKKVVKVVVVKKVKKKKVVKVKKVVKVKVKVKKKKVVKKVV
KKVVVKVKVKKKVVVKVKKVVKKVVVKKV
KKKVVKVVKKKKVVVKVVKVVKVVVVKKKVVKKVVKKKVKVKKVVVKKVKKVVVKVKVKKKVVVKVKKVVKKVKKVVKKKKVKVKKKKKVKVKKKKVK
VKVVKVVVKKKVVKKKKVVVVKVVKKVVKVVKVVVKVKVVVVVVKKK
VVVVVKKVKKVVVKKVVKVV
KVVKKKKVVKKVVVKVKKVVVVVV
VVKKKVVKVKKVVVKKKKVVKKKKVVKKVVVKKVVVVVKKVK
KVKVKVKKKVKVKKKKVVKKKKVVVKVV
VKKVVVKVVKKKKKKKKVKVKVKKK
VVKKVVKKVVKVVKKV
VVVVKKVKKVKVKVKVKVKKKVKVVKKVVVV
VKVKKKVVVVVKVKVVVKKKKKKVVVKKKKKVVVKKKVVVKVVKVKVKK
VKKVKKVKKKKKKKKVVKKVVKVKKVKV
KKVVVKVVKVVVVKKKVVKVVKVVKKKVVKKVVKKKKKKKVKVKKKKVKKKVKKKKVVKKKKKVKKKVKKVKVKKVVKVVVKVV
KKVKVVKKKKVKVVVKVVKKVKVVKVVVKVKKVV
KVVVKVKKKKKKVKVKKKVVKKKKVVVVVKVVKKKVKVVKVKKVVVKKKVKKVKKKVVKKKVKVVKVKKVVVVVKVVKKKKVVKKVKKVKKVKVKVVKV
KVKKVKKKVKKKKKKVVKVVVKVVVVVVVKVVVKVVKKVKVVVV
VVVVVVKKVKKVKKVKVKVVVKKKVVVKVVKVVVKVVVKKKKVKVKKKKVVVKKVKVKVVVKKVKKVV
KVVVVVKVKKVVKKKVVVVKVVKKK
VVVVKKVVVKKVVVVVVVKVKKVKKVV

`

func countVK(b []byte) int {
	cnt := 0
	for i := 0; i+1 < len(b); i++ {
		if b[i] == 'V' && b[i+1] == 'K' {
			cnt++
		}
	}
	return cnt
}

func referenceSolve(s string) string {
	b := []byte(s)
	best := countVK(b)
	for i := range b {
		orig := b[i]
		if b[i] == 'V' {
			b[i] = 'K'
		} else {
			b[i] = 'V'
		}
		if c := countVK(b); c > best {
			best = c
		}
		b[i] = orig
	}
	return strconv.Itoa(best)
}

func parseCases() ([]string, error) {
	scan := bufio.NewScanner(strings.NewReader(testcases))
	scan.Split(bufio.ScanWords)
	if !scan.Scan() {
		return nil, fmt.Errorf("missing test count")
	}
	t, err := strconv.Atoi(scan.Text())
	if err != nil {
		return nil, fmt.Errorf("parse t: %w", err)
	}
	cases := make([]string, 0, t)
	for i := 0; i < t; i++ {
		if !scan.Scan() {
			return nil, fmt.Errorf("case %d: missing string", i+1)
		}
		cases = append(cases, scan.Text())
	}
	if err := scan.Err(); err != nil {
		return nil, err
	}
	return cases, nil
}

func runBinary(bin, input string) (string, string, error) {
	cmd := exec.Command(bin)
	cmd.Stdin = strings.NewReader(input)
	var out bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &stderr
	err := cmd.Run()
	return out.String(), stderr.String(), err
}

func main() {
	if len(os.Args) != 2 {
		fmt.Println("usage: verifierA /path/to/binary")
		os.Exit(1)
	}
	bin := os.Args[1]

	cases, err := parseCases()
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to parse testcases: %v\n", err)
		os.Exit(1)
	}

	for idx, s := range cases {
		input := s + "\n"
		expected := referenceSolve(s)
		out, stderr, err := runBinary(bin, input)
		if err != nil {
			fmt.Fprintf(os.Stderr, "case %d: runtime error: %v\nstderr: %s\n", idx+1, err, stderr)
			os.Exit(1)
		}
		if strings.TrimSpace(out) != expected {
			fmt.Fprintf(os.Stderr, "case %d failed\nexpected: %s\ngot: %s\n", idx+1, expected, strings.TrimSpace(out))
			os.Exit(1)
		}
	}
	fmt.Printf("All %d tests passed\n", len(cases))
}
