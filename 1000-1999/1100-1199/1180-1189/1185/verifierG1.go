package main

import (
	"bufio"
	"bytes"
	"fmt"
	"math/bits"
	"os"
	"os/exec"
	"strconv"
	"strings"
)

type testcase struct {
	n  int
	T  int
	ts []int
	gs []int
}

const mod = 1000000007

const testcasesRaw = `100
3 3
4 3
1 1
5 1
3 10
1 3
2 1
1 2
4 2
2 1
5 2
1 3
1 1
5 1
5 3
4 1
2 1
5 1
3 2
4 4
4 1
5 3
2 3
3 1
2 2
1 2
1 1
5 2
4 3
5 3
2 3
5 3
5 3
4 1
4 2
5 1
4 3
4 2
4 1
2 1
4 1
2 1
4 1
5 2
1 2
2 3
3 3
1 1
2 3
5 2
4 1
1 2
4 2
2 1
4 1
5 1
3 3
5 1
3 1
5 2
5 1
4 2
4 2
1 2
3 1
5 1
2 3
2 3
5 1
5 2
3 1
4 1
5 2
1 2
4 3
3 2
4 2
4 2
5 1
1 2
4 3
3 1
5 1
5 3
3 1
1 2
2 1
5 2
5 3
2 2
2 2
4 2
2 1
4 1
4 2
3 2
5 2
2 1
1 1
4 2
3 2
4 2
2 2
5 2
4 1
4 2
3 1
5 2
4 1
4 1
2 3
5 2
3 2
5 2
3 1
4 2
4 1
5 2
4 3
3 1
2 1
2 1
4 2
5 1
2 2
2 2
5 3
3 3
3 3
2 1
5 3
2 1
5 3
2 1
3 2
5 1
5 2
5 1
3 2
4 2
2 3
5 1
3 2
4 1
1 3
2 1
4 3
5 2
4 1
3 3
5 2
2 1
1 2
5 2
1 1
5 1
4 3
3 3
3 1
1 1
3 3
4 1
1 3
4 3
4 2
4 2
2 2
5 1
1 3
5 1
3 2
5 1
3 2
3 1
3 3
5 2
3 2
3 3
3 1
2 2
4 2
1 1
5 1
1 2
5 1
5 2
5 3
5 3
4 1
2 3
5 2
3 3
5 2
5 1
2 1
3 2
3 1
3 3
5 3
1 1
2 1
5 3
3 3
4 1
5 1
5 1
3 2
2 1
2 3
3 3
4 3
4 3
5 3
3 1
2 1
2 1
2 3
5 2
3 3
2 3
5 3
3 1
5 3
5 1
1 1
3 3
2 1
5 2
4 1
3 1
3 3
4 1
5 2
2 2
2 1
5 1
4 2
3 3
1 1
3 2
3 3
3 1
3 3
4 3
1 2
2 1
3 1
4 2
5 2
2 1
5 2
2 1
5 1
2 1
1 1
4 1
5 3
2 1
5 1
2 2
2 1
5 2
4 1
5 1
4 2
2 2
4 2
5 1
5 2
5 2
2 1
4 1
3 3
1 2
4 3
4 1
5 3
5 2
2 1
1 2
3 2
2 2
2 3
1 1
2 1
5 2
2 1
5 2
5 3
2 2
5 1
4 1
3 1
2 3
4 2
5 3
2 3
5 1
3 2
3 3
4 1
2 1
4 2
2 2
1 1
3 1
5 1
5 2
1 2
3 3
1 1
2 1
4 1
3 3
1 2
2 1
5 3
4 1
1 2
1 1
4 2
1 2
3 3
5 3
2 2
5 1
5 3
2 1
1 2
5 3
2 3
1 2
4 1
5 1
4 2
4 3
4 1
5 3
1 2
4 1
4 3
4 2
1 2
1 3
4 2
5 1
5 3
4 1
2 3
4 2
5 3
1 2
4 2
3 3
3 2
4 2
3 1
2 1
4 3
2 1
2 1
5 1
1 2
4 1
2 2
3 3
1 1
3 3
1 2
1 1
5 2
5 3
3 2
5 2
2 1
4 2
5 2
1 1
2 3
1 1
1 2
1 2
2 3
3 1
1 1
5 3
1 1
3 1
5 1
3 2
4 1
5 1
2 1
2 1
1 2
2 1
1 2
5 3
1 1
1 1
3 1
1 1
2 1
4 1
3 2
4 2
4 2
2 1
1 2
2 1
1 1
1 2
5 2
5 3
2 2
4 3
4 2
5 3
2 1
3 1
4 2
3 2
2 1
4 1
1 2
4 3
2 1
2 1
4 2
5 1
5 1
3 3
2 3
5 3
1 2
4 2
3 1
3 2
5 2
5 1
2 2
2 3
2 1
2 1
2 1
3 3
4 3
1 2
2 2
4 1
2 1
4 2
5 3
3 3
1 3
4 1
5 1
4 3
2 1
5 2
4 3
5 3
3 1
3 1
4 2
4 2
5 1
4 1
1 1
5 3
2 1
2 2
3 1
4 1
5 3
1 1
3 2
4 2
4 3
5 2
3 3
1 1
3 3
2 3
2 1
4 1
3 3
5 1
3 1
4 1
1 1
4 2
2 1
4 2
4 2
5 2
4 1
5 2
5 1
4 1
5 1
1 2
3 2
4 1
2 2
4 2
5 1
3 2
1 1
5 2
2 1
1 1
4 1
2 1
5 2
5 1
4 1
2 3
4 1
5 1
4 3
5 2
5 1
5 1
3 2
2 3
3 3
5 2
2 1
4 2
3 1
4 1
3 3
5 3
1 2
5 1
5 3
5 2
2 1
2 1
2 1
5 1
1 2
5 3
2 3
4 3
4 1
3 2
5 3
2 1
2 2
5 2
2 1
5 2
3 3
3 1
4 2
1 2
5 1
2 2
3 2
5 1
5 1
2 1
5 3
1 2
2 1
4 2
1 1
3 2
3 3
5 1
2 1
5 2
2 3
3 3
3 2
4 1
4 2
4 2
4 3
5 2
2 3
1 1
3 1
5 3
5 1
1 2
3 1
1 2
4 1
5 2
2 1
5 3
2 1
5 3
1 1
2 1
5 3
5 2
4 2
3 1
1 1
3 3
5 1
5 3
3 2
2 1
2 2
3 2
2 2
5 1
5 2
3 2
5 1
2 1
1 3
4 3
2 1
4 3
4 2
5 3
4 1
3 1
4 1
3 1
5 1
5 2
2 3
5 1
1 2
4 3
1 1
5 1
3 2
1 1
4 1
2 1
1 3
3 2
1 2
4 1
5 3
2 1
4 1
1 3
4 1
2 3
2 1
5 3
2 2
5 3
2 1
4 2
5 1
3 1
3 3
2 1
5 3
5 3
2 1
2 2
3 2
1 1
2 1
5 1
5 2
5 2
1 2
5 1
5 1
4 1
2 2
1 3
5 1
1 1
1 2
5 2
2 3
5 2
1 3
3 3
5 1
5 2
5 1
2 2
5 1
1 3
5 1
4 1
3 2
2 1
5 3
4 2
2 1
1 1
5 1
2 1
5 2
2 3
2 1
5 3
2 1
4 1
4 1
5 3
2 3
5 3
2 1
5 2
3 3
2 2
4 1
5 2
5 2
2 1
5 1
2 3
1 2
2 3
5 2
2 2
2 1
3 1
4 1
4 2
5 3
2 1
1 1
2 3
5 1
4 1
5 3
5 2
3 1
1 2
3 2
5 1
5 2
2 1
5 3
2 1
5 1
4 1
5 3
5 3
5 2
2 3
2 1
5 2
4 2
4 1
5 2
2 2
2 1
5 2
1 1
5 2
1 2
5 2
1 2
5 3
5 1
2 3
5 3
5 1
5 2
5 3
5 1
2 3
2 2
4 1
2 3
5 3
3 3
5 3
1 1
5 2
2 1
2 1
5 2
2 1
1 3
2 3
2 1
4 2
5 1
2 2
5 1
2 2
5 1
5 1
2 3
4 3
5 2
2 3
3 1
4 2
4 1
2 3
4 1
5 2
2 1
1 1
4 1
5 3
2 1
5 3
2 2
2 1
5 1
1 2
5 3
5 2
4 3
4 1
5 3
5 1
5 1
2 2
2 1
3 2
1 2
3 2
5 2
4 2
2 3
2 3
5 1
5 3
4 2
3 1
1 2
3 2
1 1
5 1
5 1
5 2
2 2
5 3
5 2
4 1
2 3
5 2
5 1
5 2
1 3
4 2
1 2
3 1
2 2
5 1
2 1
5 1
2 3
5 1
3 2
3 3
5 1
4 2
1 2
3 3
5 2
3 1
2 1
1 2
1 3
4 1
5 1
3 1
2 2
5 3
2 3
5 3
5 2
5 1
4 3
1 2
3 3
5 1
5 3
5 1
4 3
5 1
5 2
1 1
5 2
5 2
2 1
5 2
5 2
4 2
5 1
4 2
2 1
5 3
5 3
5 1
2 1
3 1
4 2
5 1
4 2
4 1
5 1
5 1
4 1
3 2
2 3
2 2
5 2
5 1
2 1
5 3
5 2
4 2
5 3
5 1
5 2
5 2
1 3
1 3
2 1
3 3
3 1
3 2
3 3
5 3
2 2
2 1
5 2
5 2
2 1
2 3
5 2
5 1
5 2
4 2
4 1
5 2
2 2
3 3
5 2
2 2
1 1
2 3
5 1
5 2
2 3
5 1
1 1
5 2
5 1
5 1
5 1
5 2
4 1
2 3
5 2
5 2
4 1
5 3
2 1
5 2
3 1
5 2
5 2
3 3
3 3
5 3
5 2
3 3
4 1
5 3
5 3
2 1
5 3
4 2
3 1
5 3
1 2
5 1
5 2
4 2
5 2
3 1
3 2
4 2
2 2
5 3
1 2
2 1
5 1
2 3
5 2
3 2
5 1
2 2
3 2
2 1
5 1
5 1
5 3
5 1
2 2
3 1
5 2
5 1
5 1
5 3
5 2
2 1
5 1
4 1
2 3
5 2
2 1
5 3
2 1
1 1
1 3
1 1
5 3
5 2
1 2
2 1
5 2
2 2
5 1
4 1
5 3
5 1
3 2
5 2
5 2
2 1
3 2
3 2
4 2
5 1
1 1
5 2
5 1
2 2
5 1
2 2
5 3
2 1
1 2
3 1
4 1
1 1
5 2
3 1
1 2
5 1
5 3
2 1
4 1
2 2
5 2
5 2
5 1
5 2
2 2
5 2
5 2
4 3
5 1
5 3
5 3
4 1
4 2
5 2
5 2
1 2
3 3
5 3
5 1
4 1
4 1
2 1
4 1
2 1
5 1
5 2
4 2
1 3
2 1
5 1
5 2
2 1
2 1
5 3
5 2
5 2
2 1
2 3
5 1
2 1
5 3
2 1
5 2
2 3
2 2
5 1
5 1
5 3
5 2
5 2
2 3
2 1
5 1
5 2
5 3
5 2
2 1
4 3
1 1
5 1
1 2
3 3
2 1
2 1
5 2
4 2
5 3
4 2
2 2
3 2
2 2
1 2
5 1
5 2
1 3
5 2
5 1
2 1
3 1
4 1
5 2
5 1
5 3
2 3
5 1
5 3
3 2
5 1
2 3
2 1
5 3
2 1
5 1
5 1
5 3
5 1
2 1
2 2
5 2
3 2
5 2
5 2
4 2
2 2
3 1
4 1
3 1
5 3
5 1
4 1
2 2
5 2
4 1
3 3
3 2
2 2
5 2
2 3
2 3
4 3
3 3
2 3
5 2
1 1
3 2
5 1
5 2
5 1
2 2
2 3
4 2
5 1
5 2
1 2
4 1
5 1
5 3
2 1
2 1
1 2
1 1
2 1
5 2
4 2
5 2
4 2
2 3
5 1
5 1
2 1
5 2
2 2
5 2
1 2
4 1
2 1
5 1
2 2
5 2
5 3
2 3
2 2
3 1
5 3
2 1
3 2
5 1
5 1
5 2
5 3
2 1
5 1
4 2
4 3
2 3
5 3
5 2
3 1
3 1
4 1
2 2
5 3
3 1
1 2
5 3
5 3
2 1
2 2
1 1
2 1
2 1
4 2
5 1
5 2
5 3
4 3
5 2
4 1
2 1
2 3
4 1
4 2
5 1
5 2
4 2
3 2
5 1
4 2
3 1
5 1
1 1
5 1
5 2
5 3
3 3
5 2
3 1
4 3
2 1
5 2
2 3
3 1
5 3
5 1
2 1
5 2
5 2
3 1
5 3
5 1
5 1
2 1
4 3
1 1
2 3
4 3
4 1
2 3
5 1
2 1
5 2
5 2
2 2
5 2
2 2
5 1
3 2
5 2
2 1
2 2
5 2
5 1
3 3
3 1
2 1
5 1
5 2
5 3
5 2
4 1
2 1
5 1
5 1
2 2
4 1
3 3
5 2
5 2
5 1
5 2
3 2
2 2
3 1
2 1
5 2
5 1
3 2
2 1
2 2
5 2
5 1
1 2
2 2
5 1
5 2
3 2
4 2
3 1
2 2
4 1
2 1
5 1
5 2
5 2
2 1
2 2
2 2
5 3
2 1
5 1
2 3
5 3
5 2
2 1
5 1
5 2
1 2
5 1
3 2
5 2
2 1
5 2
2 1
5 2
3 1
5 3
2 2
1 2
5 2
5 3
2 2
4 2
4 3
5 2
1 2
4 2
5 3
5 2
3 2
3 1
5 2
2 1
5 3
5 2
2 3
5 2
2 1
5 1
5 2
5 1
5 2
2 2
2 1
5 2
1 1
2 2
2 2
5 1
5 2
4 2
2 1
5 2
5 1
1 3
4 3
5 2
4 3
5 2
4 2
5 2
5 3
3 2
2 3
2 1
5 1
2 3
5 3
3 2
1 2
4 1
5 2
1 2
5 2
2 3
5 1
5 1
5 1
1 2
5 2
5 3
2 1
5 2
5 2
5 1
3 1
2 1
1 2
5 1
5 2
5 1
5 3
3 2
2 1
1 2
5 3
1 2
2 3
1 2
3 1
4 1
5 1
5 2
5 2
2 1
5 1
2 1
5 2
5 3
2 1
5 2
5 2
2 1
3 2
5 3
2 1
2 3
5 1
5 2
1 2
5 1
2 2
2 2
2 2
5 1
2 2
4 3
5 2
4 2
2 2
2 1
5 3
5 2
5 1
5 2
5 2
3 1
3 2
5 3
1 1
2 3
5 3
5 2
3 3
2 1
2 2
5 2
4 2
5 1
1 1
4 2
2 1
5 3
4 1
5 2
5 2
5 1
5 2
5 2
5 1
5 2
3 1
5 1
1 3
2 3
2 2
4 3
5 1
4 2
3 1
4 3
2 1
5 2
2 1
2 1
5 2
5 2
5 2
4 1
2 3
4 2
4 1
2 3
5 2
4 1
4 1
2 1
5 2
5 1
2 3
1 3
4 2
1 2
5 1
4 2
5 2
3 2
5 1
2 3
5 3
2 1
1 2
5 3
2 2
1 1
5 2
5 2
3 1
3 1
3 2
3 3
4 1
4 1
5 2
4 1
4 1
5 1
4 1
4 3
4 1
4 2
2 1
5 2
1 2
2 1
2 2
5 3
5 2
5 1
2 3
5 2
1 2
2 1
5 2
3 1
1 1
5 1
5 3
2 1
4 3
2 2
2 1
5 1
5 3
4 2
2 1
5 1
2 1
5 3
5 2
2 3
3 2
4 2
5 1
5 2
2 1
3 3
4 2
2 3
5 3
5 1
5 1
5 2
2 3
2 2
1 3
5 3
2 1
5 2
4 2
5 1
2 1
4 2
5 2
2 1
4 2
2 1
5 1
4 2
3 2
5 2
2 1
5 2
5 2
5 1
5 2
2 3
1 2
5 3
5 3
5 1
3 2
3 1
5 2
2 3
4 1
2 2
5 2
3 2
1 1
5 1
2 2
5 2
5 3
5 3
5 2
1 2
1 1
5 1
4 2
1 1
1 1
5 1
3 2
2 1
5 1
2 1
1 2
4 3
3 2
5 1
1 2
1 2
5 2
5 2
2 1
2 1
1 2
5 1
5 1
4 1
2 1
5 1
2 1
4 3
5 2
2 1
5 1
3 2
5 2
4 2
2 2
5 2
5 1
3 2
5 2
2 3
5 3
2 3
5 2
2 1
5 3
4 1
5 2
2 2
2 1
5 1
1 3
2 3
3 1
5 2
5 3
4 2
2 1
5 2
2 1
3 1
5 1
5 3
2 2
4 1
5 2
1 2
5 2
5 1
1 2
4 2
2 1
4 2
5 2
2 1
4 2
2 2
4 2
5 2
5 2
3 1
3 2
5 1
5 1
5 3
5 2
5 3
2 1
5 2
4 1
5 3
2 1
5 2
5 1
1 1
2 3
2 3
4 2
5 1
5 3
4 2
4 2
5 1
5 2
2 2
5 2
5 1
1 2
5 2
5 1
5 3
3 1
5 3
5 2
2 2
5 2
1 1
2 3
2 1
5 2
3 1
2 2
1 2
2 2
5 3
5 1
1 2
1 2
2 2
5 1
2 3
2 1
4 1
4 3
4 2
5 1
5 2
5 3
5 1
4 1
5 3
2 3
4 3
2 1
5 1
4 1
5 1
5 2
5 3
5 3
2 2
5 1
5 1
5 3
5 1
2 2
5 2
4 2
3 3
5 1
5 2
5 2
2 2
5 2
5 1
3 2
5 1
5 2
5 2
5 1
2 3
1 2
3 1
5 2
5 2
2 1
5 1
4 1
5 1
5 1
5 2
5 1
5 2
2 2
4 1
2 1
2 1
5 2
5 2
1 1
2 2
5 3
1 1
5 2
5 1
5 2
2 2
5 3
4 3
5 1
5 3
2 3
5 2
4 2
5 1
5 2
5 2
2 3
2 2
5 2
5 3
2 2
3 2
1 3
2 1
5 1
5 3
3 1
2 3
5 2
3 3
2 3
5 3
5 2
5 1
1 1
5 2
2 1
1 2
4 3
1 3
5 1
4 3
1 1
4 2
3 1
5 2
2 2
5 2
2 2
4 1
4 1
2 2
5 1
1 2
5 2
2 1
5 1
5 2
2 2
5 3
2 2
5 2
2 1
5 2
5 2
5 2
4 2
5 2
5 1
5 2
5 1
2 2
2 2
2 3
5 1
2 1
5 2
3 2
3 1
5 2
3 2
4 1
5 3
3 1
2 1
5 2
2 1
5 2
3 2
4 1
2 1
2 1
5 3
5 3
4 2
2 1
5 1
5 1
5 2
3 1
2 2
1 2
2 2
5 2
5 1
1 2
5 2
1 2
2 2
5 2
4 1
4 1
5 2
5 2
5 2
2 2
4 2
5 3
2 1
5 2
5 1
5 3
1 1
5 3
2 1
5 2
2 3
5 2
5 1
5 3
5 2
5 2
5 2
5 1
5 2
5 2
2 1
5 2
4 2
5 2
2 1
4 1
4 2
5 1
3 1
5 1
1 2
1 2
2 3
5 2
1 1
4 3
4 1
4 1
5 2
5 2
5 2
2 1
5 1
2 1
1 1
2 3
5 2
2 1
5 2
2 1
4 2
5 2
5 2
2 2
4 1
5 2
5 2
3 1
2 3
5 3
5 3
5 1
4 1
1 2
5 2
5 1
2 1
5 2
2 2
5 1
5 1
5 2
5 2
5 2
5 2
2 3
5 3
2 1
5 1
5 2
5 3
5 2
1 2
5 2
1 1
1 1
5 1
2 2
5 3
2 2
5 2
4 1
5 1
2 1
4 1
2 2
3 2
2 2
2 3
4 1
2 1
4 2
5 2
2 1
5 2
5 2
5 2
5 2
5 2
3 3
5 1
5 1
2 3
5 1
5 2
4 1
5 1
5 2
2 1
5 1
4 2
1 2
5 2
3 1
5 1
4 1
2 1
4 1
4 3
5 1
5 3
5 3
4 2
5 1
5 2
3 2
2 2
5 1
2 1
5 1
1 3
4 2
2 1
1 1
4 2
2 1
4 2
5 1
1 2
5 3
5 1
2 1
5 1
5 2
5 2
2 1
4 1
4 2
5 1
2 1
2 2
2 1
5 2
5 2
5 2
2 1
5 2
2 2
5 2
2 2
5 2
5 3
5 2
5 2
5 2
5 2
5 2
1 2
5 3
5 2
5 1
2 3
5 1
2 3
1 1
5 1
5 1
5 1
5 2
5 1
3 2
5 1
4 1
5 2
5 1
5 2
4 1
5 1
5 1
4 2
5 1
5 3
4 2
5 1
4 3
3 1
5 2
2 3
4 2
5 1
5 2
5 1
2 1
5 1
5 2
2 2
5 1
5 1
5 1
2 2
5 2
3 2
5 1
5 3
2 1
1 1
3 2
2 2
4 1
5 2
5 2
5 3
5 2
5 2
4 1
1 2
5 1
5 2
2 3
1 2
5 1
1 2
5 1
5 2
5 2
1 2
2 1
5 1
2 2
3 3
3 3
5 2
4 2
3 1
5 1
5 1
5 2
5 2
5 2
5 2
5 2
2 1
4 2
2 3
1 2
5 2
5 2
4 2
5 2
5 1
5 1
1 2
1 2
5 2
2 1
2 1
5 2
5 2
5 2
2 2
5 1
2 2
1 2
5 2
5 2
5 2
5 1
1 2
4 1
5 2
2 1
5 2
4 1
5 3
4 1
1 1
5 1
5 1
5 1
5 2
5 1
5 2
2 1
2 2
2 2
5 2
1 2
2 2
3 2
2 2
1 2
4 2
5 2
5 1
5 2
5 2
2 2
5 2
2 2
2 2
5 2
5 1
5 2
5 2
1 2
5 2
3 2
5 2
2 2
5 3
5 2
2 2
5 1
1 1
5 1
5 3
5 2
2 1
2 1
5 3
4 1
3 2
5 2
1 2
2 2
2 1
1 2
2 3
5 1
2 1
5 1
5 2
5 1
2 1
5 2
5 2
2 2
5 1
3 2
2 2
5 2
4 1
5 1
3 3
2 1
5 2
3 2
5 1
5 3
5 2
5 2
4 1
3 2
5 2
5 2
5 2
5 3
5 2
5 2
5 2
5 2
4 3
5 2
1 2
5 3
3 2
4 1
5 2
5 2
5 1
5 1
2 2
5 3
5 2
5 1
5 2
5 2
5 2
5 3
5 1
5 2
5 2
5 2
5 1
5 1
5 3
5 2
5 2
5 2
5 1
5 2
5 2
5 2
5 2
5 2
2 2
5 1
5 2
5 2
5 2
5 2
5 2
5 2
5 1
5 2
5 2
5 2
2 2
5 2
5 2
5 2
5 2
5 1
5 2
5 2
5 1
5 2
5 2
5 1
5 2
5 2
5 2
5 2
5 2
5 2
5 2
5 2
5 2
5 2
5 2
5 2
5 2
5 2
5 2
5 2`

var testcases = mustParseTestcases(testcasesRaw)

func mustParseTestcases(raw string) []testcase {
	lines := strings.Split(strings.TrimSpace(raw), "\n")
	if len(lines) == 0 {
		panic("empty testcases")
	}
	idx := 0
	T, err := strconv.Atoi(strings.TrimSpace(lines[idx]))
	if err != nil {
		panic(fmt.Sprintf("bad T: %v", err))
	}
	idx++
	cases := make([]testcase, 0, T)
	for c := 0; c < T; c++ {
		if idx >= len(lines) {
			panic("unexpected EOF while reading cases")
		}
		parts := strings.Fields(lines[idx])
		idx++
		if len(parts) != 2 {
			panic(fmt.Sprintf("case %d: expected n T", c+1))
		}
		n, _ := strconv.Atoi(parts[0])
		Tm, _ := strconv.Atoi(parts[1])
		ts := make([]int, n)
		gs := make([]int, n)
		for i := 0; i < n; i++ {
			if idx >= len(lines) {
				panic(fmt.Sprintf("case %d: missing song line %d", c+1, i+1))
			}
			p := strings.Fields(lines[idx])
			idx++
			if len(p) != 2 {
				panic(fmt.Sprintf("case %d song %d: expected two ints", c+1, i+1))
			}
			t, _ := strconv.Atoi(p[0])
			g, _ := strconv.Atoi(p[1])
			ts[i] = t
			gs[i] = g
		}
		cases = append(cases, testcase{n: n, T: Tm, ts: ts, gs: gs})
	}
	return cases
}

func solve(tc testcase) int {
	n := tc.n
	T := tc.T
	t := tc.ts
	g := tc.gs
	size := 1 << n
	timeSum := make([]int, size)
	for mask := 1; mask < size; mask++ {
		lb := mask & -mask
		idx := bits.TrailingZeros(uint(lb))
		timeSum[mask] = timeSum[mask^lb] + t[idx]
	}
	dp := make([][4]int, size)
	dp[0][0] = 1
	for mask := 0; mask < size; mask++ {
		for last := 0; last < 4; last++ {
			val := dp[mask][last]
			if val == 0 {
				continue
			}
			for i := 0; i < n; i++ {
				if mask&(1<<i) != 0 || g[i] == last {
					continue
				}
				nm := mask | (1 << i)
				dp[nm][g[i]] += val
				if dp[nm][g[i]] >= mod {
					dp[nm][g[i]] -= mod
				}
			}
		}
	}
	ans := 0
	for mask := 0; mask < size; mask++ {
		if timeSum[mask] != T {
			continue
		}
		for last := 1; last <= 3; last++ {
			ans += dp[mask][last]
			if ans >= mod {
				ans -= mod
			}
		}
	}
	return ans
}

func runCandidate(bin, input string) (string, error) {
	cmd := exec.Command(bin)
	cmd.Stdin = strings.NewReader(input)
	var out bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &out
	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("runtime error: %v\n%s", err, out.String())
	}
	return out.String(), nil
}

func parseCandidateOutput(out string) (int, error) {
	scanner := bufio.NewScanner(strings.NewReader(out))
	scanner.Split(bufio.ScanWords)
	if !scanner.Scan() {
		return 0, fmt.Errorf("no output")
	}
	v, err := strconv.Atoi(scanner.Text())
	if err != nil {
		return 0, fmt.Errorf("failed to parse output: %v", err)
	}
	if err := scanner.Err(); err != nil {
		return 0, fmt.Errorf("scanner error: %v", err)
	}
	return v, nil
}

func checkCase(bin string, idx int, tc testcase) error {
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("%d %d\n", tc.n, tc.T))
	for i := 0; i < tc.n; i++ {
		sb.WriteString(fmt.Sprintf("%d %d\n", tc.ts[i], tc.gs[i]))
	}
	input := sb.String()
	expected := solve(tc)
	out, err := runCandidate(bin, input)
	if err != nil {
		return err
	}
	got, err := parseCandidateOutput(out)
	if err != nil {
		return err
	}
	if got != expected {
		return fmt.Errorf("case %d: expected %d got %d", idx+1, expected, got)
	}
	return nil
}

func main() {
	if len(os.Args) != 2 {
		fmt.Println("Usage: go run verifierG1.go /path/to/binary")
		os.Exit(1)
	}
	bin := os.Args[1]
	for i, tc := range testcases {
		if err := checkCase(bin, i, tc); err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
	}
	fmt.Printf("All %d tests passed\n", len(testcases))
}
