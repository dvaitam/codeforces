package main

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"strconv"
	"strings"
)

const testcasesRaw = `
6 5 868 822 783 65 262 121
17 15 484 668 389 808 215 97 500 30 915 856 400 444 623 781 786 3 713
16 9 739 822 235 606 968 105 924 326 32 23 27 666 555 10 962 903
14 11 222 993 433 744 30 541 228 783 449 962 508 567 239 354
9 4 780 471 976 297 949 23 427 858 939
19 4 191 645 742 881 304 124 761 341 918 739 997 729 513 959 991 433 520 850 933
8 5 291 602 997 904 512 867 964 518
14 10 874 36 492 249 762 817 414 425 681 178 376 562 904 720
13 2 450 680 521 111 798 168 534 861 403 380 502 751 31
17 2 316 721 869 630 608 593 404 663 175 173 515 233 13 790 205 553 943
19 8 415 527 353 976 868 592 362 471 932 276 676 562 624 981 747 6 393 803 878
18 5 532 797 575 211 437 973 58 493 891 374 584 568 205 964 517 424 497 833
13 7 355 2 552 554 639 806 628 340 470 615 29 824 236
7 5 599 186 882 94 818 565 817
10 1 862 967 690 73 86 889 18 464 15 773
10 4 276 113 817 640 190 353 298 72 172 164
10 9 975 173 673 280 664 729 302 466 720 330
17 16 117 25 320 396 352 432 816 193 265 112 260 922 748 523 215 989 621
15 14 999 22 231 19 407 150 37 737 983 165 457 722 519 695 437
19 8 646 817 712 529 462 229 537 665 32 405 692 590 823 329 676 647 437 61 756
11 3 992 218 897 49 314 73 880 79 318 940 962
11 3 427 579 259 134 9 575 900 871 39 605 840
8 8 176 848 889 891 998 799 721 638
18 2 388 206 356 102 211 588 691 919 444 606 199 505 107 961 682 400 304 517
17 1 334 627 893 412 922 289 19 161 206 879 336 831 577 802 139 348 440
8 5 691 99 858 389 955 561 353 937
19 16 787 546 241 67 743 42 87 137 174 171 933 552 219 275 778 341 615 519 862
10 6 347 349 117 299 241 889 967 619 799 978
17 5 594 565 789 107 329 41 417 75 390 887 808 151 849 129 350 118 630
20 13 79 585 564 230 580 84 976 274 374 913 303 578 548 948 118 469 919 284 111 806
3 2 13 629 687
2 1 424 118
3 1 246 805 601
15 3 119 462 172 698 248 163 762 866 106 446 933 988 388 826 994
19 10 564 260 729 489 323 103 213 668 326 41 28 11 806 948 303 744 611 328 461
14 6 409 65 66 936 325 994 616 467 115 257 221 804 633 797
19 16 678 365 266 188 555 213 315 204 253 370 84 840 288 92 772 459 93 668 589
12 4 400 990 315 43 336 192 325 812 868 593 915 944
11 4 343 104 558 627 593 827 611 95 251 226 21
9 7 75 275 565 889 73 747 77 23 651
2 2 769 812
13 8 481 884 880 158 104 514 797 815 336 79 522 973 682
7 2 795 154 145 842 887 328 313
5 5 855 942 617 301 130
8 3 559 933 740 33 799 324 841 925
19 7 183 307 444 551 162 50 732 883 684 254 259 797 66 699 987 458 828 441 563
10 9 450 872 551 465 12 406 857 347 176 265
17 1 813 662 956 427 585 20 64 709 364 594 142 608 129 266 849 284 408
20 13 177 628 92 240 498 8 182 542 325 513 915 665 943 449 953 703 655 749 232 245
12 8 704 491 980 231 730 423 346 574 626 929 746 940
10 4 50 944 74 782 524 661 899 378 164 785
8 5 306 710 307 870 566 381 170 719
16 3 877 127 919 621 984 527 585 387 181 160 257 437 223 965 584 737
3 2 698 404 735
13 7 528 866 169 558 748 42 537 93 828 262 644 104 274
4 2 993 795 632 863
4 4 872 947 247 995
14 13 926 444 407 169 932 334 449 130 638 931 500 983 218 123
15 10 547 419 932 121 677 303 285 255 388 768 573 5 983 195 542
16 1 32 643 997 621 249 856 267 212 178 292 152 556 206 280 319 600
10 8 811 882 829 876 997 173 559 366 503 431
5 2 585 901 393 210 291
5 1 121 583 766 14 559
11 11 780 742 997 665 140 77 513 383 587 825 319
15 9 694 366 777 542 332 1 127 453 736 461 359 313 553 409 348
20 16 116 664 940 387 392 209 571 4 285 651 613 740 903 757 850 746 524 204 946 473
18 14 960 763 730 313 720 175 461 635 685 544 203 369 539 4 695 399 594 437
14 6 882 637 599 998 752 717 920 991 767 70 505 764 254 656
11 11 22 417 739 645 160 649 798 960 407 802 277
7 7 76 835 795 620 11 358 935
10 7 895 702 558 311 156 474 853 266 497 174
16 2 278 523 101 763 605 433 72 364 69 673 454 21 169 520 728 969
7 6 96 412 652 706 283 620 312
8 4 243 908 342 276 71 77 716 851
18 12 480 524 572 755 51 173 305 669 753 731 835 570 277 365 625 758 238 402
19 13 177 496 809 266 888 626 338 734 228 265 987 625 724 251 865 677 32 873 921
14 6 951 443 956 780 255 805 276 195 75 641 750 170 892 997
20 15 596 936 956 746 152 621 969 269 471 540 167 142 798 916 733 452 370 318 770 411
9 2 736 212 698 313 70 109 234 407 330
17 4 979 192 47 57 829 612 24 911 771 222 700 36 507 721 542 835 742
16 11 679 858 282 121 628 710 177 98 228 410 239 507 461 387 769 173
9 4 840 291 474 561 594 399 217 463 733
10 6 509 608 114 932 219 81 48 16 817 6
17 11 911 393 869 595 295 941 201 410 164 902 845 777 662 156 813 936 32
2 2 149 898
19 2 579 389 261 134 82 474 668 861 311 928 15 37 550 63 538 133 44 956 281
5 4 94 195 29 512 653
6 6 286 704 837 866 197 679
16 13 338 647 275 993 267 658 651 249 252 62 603 958 807 605 180 359
15 10 715 574 654 535 993 63 927 362 561 423 552 205 729 902 550
15 15 679 72 731 274 762 626 739 996 771 75 258 182 99 155 61
8 7 873 46 55 653 94 935 833 526
17 17 380 102 321 42 130 545 34 454 681 132 917 405 782 725 921 904 457
2 2 93 257
12 2 310 36 881 394 60 751 268 321 753 134 267 814
14 13 120 877 695 312 97 436 862 252 515 571 211 339 946 347
18 13 980 918 599 493 108 133 669 835 460 537 573 737 865 855 596 719 533 549
2 2 762 161
8 6 399 534 333 100 420 354 130 589
4 1 308 835 819 667
`

type testCase struct {
	n int
	k int
	a []int
}

func parseTestcases(raw string) ([]testCase, error) {
	fields := strings.Fields(raw)
	cases := make([]testCase, 0)
	pos := 0
	for pos < len(fields) {
		if pos+2 > len(fields) {
			return nil, fmt.Errorf("truncated data")
		}
		n, err := strconv.Atoi(fields[pos])
		if err != nil {
			return nil, fmt.Errorf("bad n")
		}
		k, err := strconv.Atoi(fields[pos+1])
		if err != nil {
			return nil, fmt.Errorf("bad k")
		}
		pos += 2
		if pos+n > len(fields) {
			return nil, fmt.Errorf("incomplete array")
		}
		arr := make([]int, n)
		for i := 0; i < n; i++ {
			val, err := strconv.Atoi(fields[pos+i])
			if err != nil {
				return nil, fmt.Errorf("bad value")
			}
			arr[i] = val
		}
		pos += n
		cases = append(cases, testCase{n: n, k: k, a: arr})
	}
	return cases, nil
}

func solve(n, k int, a []int) int {
	r := a[k-1]
	prefix := make([]int, n+1)
	for i := 1; i <= n; i++ {
		if a[i-1] > prefix[i-1] {
			prefix[i] = a[i-1]
		} else {
			prefix[i] = prefix[i-1]
		}
	}
	prefixWithout := make([]int, n+1)
	mx := 0
	for i := 1; i <= n; i++ {
		if i == k {
			prefixWithout[i] = mx
		} else {
			if a[i-1] > mx {
				mx = a[i-1]
			}
			prefixWithout[i] = mx
		}
	}
	ng := make([]int, n+2)
	nextIdx := n + 1
	for i := n; i >= 1; i-- {
		if a[i-1] > r {
			nextIdx = i
		}
		ng[i] = nextIdx
	}
	ans := 0
	for p := 1; p <= n; p++ {
		b := a[p-1]
		var pref int
		if p <= k {
			pref = prefix[p-1]
		} else {
			pref = prefixWithout[p-1]
			if k <= p-1 && b > pref {
				pref = b
			}
		}
		q := ng[p+1]
		if p < k && b > r && k < q {
			q = k
		}
		var wins int
		if p == 1 {
			if q == n+1 {
				wins = n - 1
			} else {
				wins = q - 2
			}
		} else {
			if r <= pref {
				wins = 0
			} else {
				if q == n+1 {
					wins = n - p + 1
				} else {
					wins = q - p
				}
			}
		}
		if wins > ans {
			ans = wins
		}
	}
	return ans
}

func buildInput(tc testCase) string {
	var sb strings.Builder
	sb.WriteString("1\n")
	sb.WriteString(fmt.Sprintf("%d %d\n", tc.n, tc.k))
	for i, v := range tc.a {
		if i > 0 {
			sb.WriteByte(' ')
		}
		sb.WriteString(strconv.Itoa(v))
	}
	sb.WriteByte('\n')
	return sb.String()
}

func run(bin, input string) (string, error) {
	cmd := exec.Command(bin)
	cmd.Stdin = strings.NewReader(input)
	var out bytes.Buffer
	var errBuf bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &errBuf
	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("runtime error: %v\n%s", err, errBuf.String())
	}
	return strings.TrimSpace(out.String()), nil
}

func main() {
	if len(os.Args) != 2 {
		fmt.Println("usage: go run verifierB.go /path/to/binary")
		os.Exit(1)
	}
	bin := os.Args[1]

	cases, err := parseTestcases(testcasesRaw)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to parse testcases: %v\n", err)
		os.Exit(1)
	}

	for idx, tc := range cases {
		input := buildInput(tc)
		expected := solve(tc.n, tc.k, tc.a)
		got, err := run(bin, input)
		if err != nil {
			fmt.Printf("case %d: %v\n", idx+1, err)
			os.Exit(1)
		}
		if strings.TrimSpace(got) != strconv.Itoa(expected) {
			fmt.Printf("case %d failed: expected %d got %s\n", idx+1, expected, got)
			os.Exit(1)
		}
	}
	fmt.Printf("All %d tests passed\n", len(cases))
}
