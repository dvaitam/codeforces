package main

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"strconv"
	"strings"
)

const testcasesRaw = `
25 1011111100100101001101110
36 111000101101000001001101101011011010
13 0011000000110
14 11111010110001
8 01011000
45 000000010100000010001010001110010010111000001
34 1010011111100101010011110111000100
15 111011001010110
3 111
30 010000111000000001100110011010
42 100100001110111100110001111010010011101010
4 1001
26 11100111101011011001000000
25 0011110101010101000100111
14 00000111001011
34 1111000111001011100000001011001110
37 0010111100001110111111000011001101001
27 011100100001010110011010110
34 0011101100011000011001100100100111
2 11
47 10100101100010000000110000101110001111110001010
9 010001110
9 010001110
38 11100110110111011100010011011001101101
49 0101100101011010110010011110111000011100001110001
41 11111000011101111011110110100011100010100
40 0110010011110111010100011111100100100001
4 0010
46 1111011111011000010100010101010011111000100100
17 11111100100111011
30 100000010101100010011110101111
18 000001001010011010
44 10001101110001100100000100001101001111000111
46 0101011100010110110101001010000001001100110110
42 111011100110000010000000101001110010110101
11 11111011101
44 01101110010110111001010010001111111100001010
47 11001100000111110111110100011101001001100010101
16 1000101111111010
32 01011110110110110001100001010110
49 1100110000100101000101111101000010010101010010001
39 111110010000100101100101011111100110101
7 0010010
21 111001100011010010011
11 00000101100
16 1100100111010001
46 0000100000010111001010011011011010110111010101
26 00010111011001110101101100
17 01110110111010001
11 01110010000
11 00011110110
22 1011011111110000000101
6 000111
7 1111000
50 00010111001010101101010111110010101001110110010100
43 0000011011100001110011100110110010111100111
15 111111101101010
48 011001111011101001110100101010001000010000010010
35 00011101010101111001001000101010010
33 110110111010101110101101011100111
42 100010001010110110010101010101001100000010
43 0111100111111100000110100100110001110010011
20 00001011011011101000
21 101111001000010011101
19 1001001011010101000
32 00100001011011001101001110001001
13 1101100110101
44 10001011100010111011110110001100010001011001
19 1111001000010010001
46 0000010100101101100000001111111000000010101001
43 1111001011111011111111001010011111100110000
17 00001100001011110
38 10000110101001010001000111001011111101
49 0011110100001101110100000011101001000100101110100
42 000111101000010000101010010111110011111100
10 1100000100
34 1111111100111000101100001010111110
42 011001011100101111011011100101101010010011
14 01001011101110
3 000
36 101111110001011111100000100000101001
19 0000001110100010001
35 10101000001001010011101001111101100
25 0001011000111101110001110
30 010010100000011000010000011110
23 10001000001101111100110
15 010011010011010
13 1111001010011
10 0110000110
3 110
44 10010000111100001000000000101111000101111101
42 000000110110110101101101010110111000101101
31 1101100011001110110001110111110
6 100011
16 1010101101000011
29 00111011000010101001000010011
45 010100010101101101010111111110001101110001001
45 100111110000100110010110011110001111011101110
26 11111110101111001010100100
12 000011011110
`

type testCase struct {
	n int
	s string
}

func parseTestcases(raw string) ([]testCase, error) {
	lines := strings.Split(raw, "\n")
	cases := make([]testCase, 0)
	for idx, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		parts := strings.Fields(line)
		if len(parts) != 2 {
			return nil, fmt.Errorf("line %d: expected 2 fields", idx+1)
		}
		n, err := strconv.Atoi(parts[0])
		if err != nil {
			return nil, fmt.Errorf("line %d: bad n", idx+1)
		}
		s := parts[1]
		if len(s) != n {
			return nil, fmt.Errorf("line %d: length mismatch", idx+1)
		}
		cases = append(cases, testCase{n: n, s: s})
	}
	return cases, nil
}

func solve(n int, s string) string {
	ones := 0
	positions := make([]int, 0, n)
	for i := 0; i < n; i++ {
		if s[i] == '1' {
			ones++
			positions = append(positions, i)
		}
	}
	res := "NO"
	if n <= 2 {
		if ones == 0 {
			res = "YES"
		}
	} else {
		if ones%2 == 0 {
			if ones == 2 {
				if positions[1]-positions[0] > 1 {
					res = "YES"
				}
			} else {
				res = "YES"
			}
		}
	}
	return res
}

func buildInput(tc testCase) string {
	var sb strings.Builder
	sb.WriteString("1\n")
	sb.WriteString(fmt.Sprintf("%d\n%s\n", tc.n, tc.s))
	return sb.String()
}

func run(bin, input string) (string, error) {
	cmd := exec.Command(bin)
	cmd.Stdin = strings.NewReader(input)
	var out bytes.Buffer
	var errBuf bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &errBuf
	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("runtime error: %v\n%s", err, errBuf.String())
	}
	return strings.TrimSpace(out.String()), nil
}

func main() {
	if len(os.Args) != 2 {
		fmt.Println("usage: go run verifierA.go /path/to/binary")
		os.Exit(1)
	}
	bin := os.Args[1]

	cases, err := parseTestcases(testcasesRaw)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to parse testcases: %v\n", err)
		os.Exit(1)
	}

	for idx, tc := range cases {
		input := buildInput(tc)
		expected := solve(tc.n, tc.s)
		got, err := run(bin, input)
		if err != nil {
			fmt.Printf("case %d failed: %v\n", idx+1, err)
			os.Exit(1)
		}
		if strings.TrimSpace(got) != expected {
			fmt.Printf("case %d failed: expected %s got %s\n", idx+1, expected, got)
			os.Exit(1)
		}
	}
	fmt.Printf("All %d tests passed\n", len(cases))
}
