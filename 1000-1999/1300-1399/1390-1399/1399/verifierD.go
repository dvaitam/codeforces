package main

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"strconv"
	"strings"
)

// Embedded testcases from testcasesD.txt.
const testcasesRaw = `34 0100110001111110001111001000111010
12 100101001000
49 1011101111110010110101010001001110100101100011100
13 1011010011010
4 0000
9 101010011
3 111
15 101000110010101
47 11100100000001101111101011111100000110100100011
45 100011010111011010101000100100101100101110010
14 00010001111010
32 11010011001100011001000111011110
32 00110011010011000111101010100110
23 01001100000011000100010
22 0111111111101100110101
44 00100111100111010101001110110010001010001110
19 1010010000001111111
36 110100110101010011110010001110101100
18 100011010100101000
33 010111001101011101100101110000011
42 011100000001111101100010100111110000101110
33 110111110100000010010101000000111
7 0011110
10 1110110010
32 00110011111000000000011101001100
9 000100000
48 000010000011110100010000001101110111101110000000
40 1000011110010000110111100011101110000010
6 010101
34 1101000011000101110000101111010001
21 100110101011111100011
48 101000011100010000111010001100110111101010101100
9 111011001
12 110011011000
34 1100101000101011011110110011101110
22 0100010111000001001001
13 1100000010110
29 10101110000000110000010101100
39 101011011010101100101000111001000100110
31 0010100101001100001100001101001
15 011011111011101
25 1001101110010011001110110
49 0010011001001000110100010111101000110111110001000
18 000011101101011111
19 0011000010100101011
29 01101011011010110010111000100
23 01101110111011100010101
30 011001011111001010011110111010
31 1000101110011111010001011000000
11 10000111001
24 011011010100011111110111
33 010011010011001000001000010110011
20 10000001010110110001
43 1001111010001110100110010001110100111000111
48 110000001111001001010110011100110100100011010001
17 00000011111101001
48 110101110100000111111100111001111001010000101100
45 010001111111000000101000011000111110101000000
21 010111010000000010000
9 011001001
45 010110101100001101000011001111111100000101101
19 0010010011111101010
37 0101110110011100001011010110010111100
16 1000001001010010
5 00100
21 110100010101011011101
27 101010100000100000010000000
35 01100110100000010111100111010111111
17 10111101000000000
40 1010111100011110000010011100100100011010
14 01011100111001
17 01110010000101010
19 0000001000001101100
11 10011011111
4 1011
6 100110
23 00100011111101100000100
23 01100111011100110100011
12 011111111100
17 11010111000100001
22 1101000110011101101000
30 100100110010111010110001011010
42 011101011011000110011111010001111010110010
3 011
42 010100110011101100111010101010010000110011
3 111
5 10111
31 0001000111111101010111111010101
8 10111001
20 00111101001011110010
50 01110101011011000100101100101010110001110010110111
1 0
11 00011001011
31 1011100001011111110100010100011
25 1101100100111110111011101
13 0110001100010
6 000010
48 001100110110011011100010010101011010011001101010
27 011010001000100101010000110
11 01110010100`

type testCase struct {
	s string
}

func parseTestcases() []testCase {
	lines := strings.Split(strings.TrimSpace(testcasesRaw), "\n")
	tests := make([]testCase, 0, len(lines))
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		parts := strings.Fields(line)
		if len(parts) != 2 {
			panic("invalid testcase line")
		}
		n, err := strconv.Atoi(parts[0])
		if err != nil {
			panic("invalid n")
		}
		if n != len(parts[1]) {
			panic("length mismatch")
		}
		tests = append(tests, testCase{s: parts[1]})
	}
	return tests
}

// referenceSolution implements 1399D.go logic.
func referenceSolution(s string) (int, []int) {
	var stack0, stack1 []int
	res := make([]int, len(s))
	cnt := 0
	for i := 0; i < len(s); i++ {
		bit := s[i] - '0'
		var id int
		if bit == 0 {
			if len(stack1) > 0 {
				id = stack1[len(stack1)-1]
				stack1 = stack1[:len(stack1)-1]
			} else {
				cnt++
				id = cnt
			}
			stack0 = append(stack0, id)
		} else {
			if len(stack0) > 0 {
				id = stack0[len(stack0)-1]
				stack0 = stack0[:len(stack0)-1]
			} else {
				cnt++
				id = cnt
			}
			stack1 = append(stack1, id)
		}
		res[i] = id
	}
	return cnt, res
}

func run(bin, input string) (string, error) {
	var cmd *exec.Cmd
	if strings.HasSuffix(bin, ".go") {
		cmd = exec.Command("go", "run", bin)
	} else {
		cmd = exec.Command(bin)
	}
	cmd.Stdin = strings.NewReader(input)
	var out bytes.Buffer
	var errBuf bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &errBuf
	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("runtime error: %v\n%s", err, errBuf.String())
	}
	return strings.TrimSpace(out.String()), nil
}

func main() {
	if len(os.Args) != 2 {
		fmt.Println("usage: go run verifierD.go /path/to/binary")
		os.Exit(1)
	}
	bin := os.Args[1]
	tests := parseTestcases()
	for idx, tc := range tests {
		var sb strings.Builder
		sb.WriteString("1\n")
		sb.WriteString(fmt.Sprintf("%d %s\n", len(tc.s), tc.s))
		k, seq := referenceSolution(tc.s)
		expected := fmt.Sprintf("%d\n", k)
		for i, v := range seq {
			if i > 0 {
				expected += " "
			}
			expected += strconv.Itoa(v)
		}
		got, err := run(bin, sb.String())
		if err != nil {
			fmt.Printf("case %d failed: %v\n", idx+1, err)
			os.Exit(1)
		}
		if strings.TrimSpace(got) != strings.TrimSpace(expected) {
			fmt.Printf("case %d failed:\nexpected:%s\ngot:%s\n", idx+1, expected, got)
			os.Exit(1)
		}
	}
	fmt.Printf("All %d tests passed\n", len(tests))
}
