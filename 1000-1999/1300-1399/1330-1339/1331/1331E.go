package main

import (
	"bufio"
	"fmt"
	"os"
)

var grid = []string{
	"......................#.##################......................",
	"....................########################....................",
	".................############################.#.................",
	"................################################................",
	"..............####################################..............",
	".............######################################.............",
	"...........##########################################...........",
	"..........###...######################################..........",
	".........##......#..################################.##.........",
	"........##............########################.####...##........",
	".......##....................#.......##....##..........##.......",
	"......##................................................##......",
	"......##................................................##......",
	".....##..................................................##.....",
	"....##....................................................##....",
	"....##....................................................##....",
	"...##......................................................##...",
	"..###.......................................................##..",
	"...####............###.##..............###.#.#.............###..",
	"..##.####.........########............##########........#####...",
	".#####.####.....##########............###########.#..######.##..",
	".##.####.####.#############...........##################.######.",
	"##....####.##################........################.######..##",
	"##......######################.......##############.#####.....##",
	"##........#####################.....###################.......##",
	"##.......######################.....####################......##",
	"#.........#####################...######################.......#",
	"#.........######################.#######################.......#",
	"#.........##############################################.......#",
	"#.........##############################################.......#",
	"#..........############################################........#",
	"#.........##############################################.......#",
	"#..........#############################################.......#",
	"#...........###########################################........#",
	"#..........###########################################.........#",
	"#...........#########################################..........#",
	"#............#.######################################..........#",
	"#...............#########.#.########..##############...........#",
	"##..............#########...#######......#########............##",
	"##...............##.####....########.......###.##.............##",
	"##........................#########...........................##",
	"##.......................#########............................##",
	".##......##..............#########...........................##.",
	".##.....#####.............#######....................#.......##.",
	"..##.....########...........#####..........#.....#.####.....##..",
	"..##.....#########.#.###..#######.#.##.#..###..#########....##..",
	"..##.....##############################################.....##..",
	"...##.....############################################.....##...",
	"....##.....#########################################......##....",
	"....##......#######################################.......##....",
	".....##......#####################################.......##.....",
	"......##......##################################........##......",
	"......##.......################################.........##......",
	".......##.......##############################.........##.......",
	"........##.......#########################.#..........##........",
	".........##.......#..######################..........##.........",
	"..........###.........########.###########.........###..........",
	"...........###..........####....####.####.........###...........",
	".............###.................#..............###.............",
	"..............###..............................###..............",
	"................####........................####................",
	".................#####....................#####.................",
	"....................######............######....................",
	"......................####################......................",
}

func computeInside() [][]bool {
	h := len(grid)
	w := len(grid[0])
	arr := make([][]int, h)
	for i := range arr {
		arr[i] = make([]int, w)
		for j := 0; j < w; j++ {
			if grid[i][j] == '#' {
				arr[i][j] = 1
			}
		}
	}

	visited := make([][]bool, h)
	for i := range visited {
		visited[i] = make([]bool, w)
	}

	type pair struct{ x, y int }
	q := make([]pair, 0)
	push := func(x, y int) {
		if !visited[x][y] {
			visited[x][y] = true
			q = append(q, pair{x, y})
		}
	}
	for i := 0; i < h; i++ {
		if arr[i][0] == 0 {
			push(i, 0)
		}
		if arr[i][w-1] == 0 {
			push(i, w-1)
		}
	}
	for j := 0; j < w; j++ {
		if arr[0][j] == 0 {
			push(0, j)
		}
		if arr[h-1][j] == 0 {
			push(h-1, j)
		}
	}
	for len(q) > 0 {
		p := q[0]
		q = q[1:]
		dirs := [][2]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}
		for _, d := range dirs {
			nx, ny := p.x+d[0], p.y+d[1]
			if nx >= 0 && nx < h && ny >= 0 && ny < w {
				if arr[nx][ny] == 0 && !visited[nx][ny] {
					push(nx, ny)
				}
			}
		}
	}

	inside := make([][]bool, h)
	for i := range inside {
		inside[i] = make([]bool, w)
	}
	for i := 0; i < h; i++ {
		for j := 0; j < w; j++ {
			if arr[i][j] == 0 {
				if !visited[i][j] {
					inside[i][j] = true
				}
			} else {
				isInside := true
				dirs := [][2]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}
				for _, d := range dirs {
					nx, ny := i+d[0], j+d[1]
					if nx < 0 || nx >= h || ny < 0 || ny >= w || visited[nx][ny] {
						isInside = false
						break
					}
				}
				if isInside {
					inside[i][j] = true
				}
			}
		}
	}
	return inside
}

func main() {
	in := bufio.NewReader(os.Stdin)
	var row, col int
	if _, err := fmt.Fscan(in, &row, &col); err != nil {
		return
	}
	if row < 0 || row >= 64 || col < 0 || col >= 64 {
		fmt.Println("OUT")
		return
	}
	inside := computeInside()
	if inside[row][col] {
		fmt.Println("IN")
	} else {
		fmt.Println("OUT")
	}
}
